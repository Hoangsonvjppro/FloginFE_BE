% NỘI DUNG BỔ SUNG CHO CÂU 2 - UNIT TESTING VÀ TDD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Unit Testing - Câu 2 (20 điểm)}

\subsection{Câu 2.1: Login - Unit Tests Frontend và Backend (10 điểm)}

\subsubsection{Frontend Unit Tests - Validation Login (5 điểm)}

\textbf{a) Unit tests cho validateUsername() (2 điểm)}:

\textbf{File}: \texttt{src/tests/unit/validators.test.js}

\begin{verbatim}
describe('validateUsername', () => {
    // Test username rỗng
    test('should return error for null username', () => {
        expect(validateUsername(null)).toBe('Username is required');
    });

    test('should return error for empty string', () => {
        expect(validateUsername('')).toBe('Username is required');
    });

    // Test username quá ngắn/dài
    test('should return error for username too short (< 3 chars)', () => {
        expect(validateUsername('ab'))
            .toBe('Username must be at least 3 characters');
    });

    test('should return error for username too long (> 50 chars)', () => {
        const longUsername = 'a'.repeat(51);
        expect(validateUsername(longUsername))
            .toBe('Username must not exceed 50 characters');
    });

    test('should return null for min valid length (3 chars)', () => {
        expect(validateUsername('abc')).toBeNull();
    });

    test('should return null for max valid length (50 chars)', () => {
        expect(validateUsername('a'.repeat(50))).toBeNull();
    });

    // Test ký tự đặc biệt không hợp lệ
    test('should return error for username with @ symbol', () => {
        expect(validateUsername('john@example'))
            .toBe('Username can only contain letters, numbers, 
                   dots, hyphens, and underscores');
    });

    test('should return error for username with spaces', () => {
        expect(validateUsername('john doe'))
            .toBe('Username can only contain letters, numbers, 
                   dots, hyphens, and underscores');
    });

    // Test username hợp lệ
    test('should return null for valid username', () => {
        expect(validateUsername('user123')).toBeNull();
    });

    test('should return null for username with dots', () => {
        expect(validateUsername('john.doe')).toBeNull();
    });

    test('should return null for username with hyphens', () => {
        expect(validateUsername('john-doe')).toBeNull();
    });

    test('should return null for username with underscores', () => {
        expect(validateUsername('john_doe')).toBeNull();
    });
});
\end{verbatim}

\textbf{b) Unit tests cho validatePassword() (2 điểm)}:

\begin{verbatim}
describe('validatePassword', () => {
    // Test password rỗng
    test('should return error for null password', () => {
        expect(validatePassword(null)).toBe('Password is required');
    });

    test('should return error for empty string', () => {
        expect(validatePassword('')).toBe('Password is required');
    });

    // Test password quá ngắn/dài
    test('should return error for password < 6 chars', () => {
        expect(validatePassword('Pass1'))
            .toBe('Password must be at least 6 characters');
    });

    test('should return error for password > 100 chars', () => {
        const longPassword = 'a'.repeat(50) + '1'.repeat(51);
        expect(validatePassword(longPassword))
            .toBe('Password must not exceed 100 characters');
    });

    // Test password không có chữ hoặc số
    test('should return error for password without numbers', () => {
        expect(validatePassword('Password'))
            .toBe('Password must contain at least one number');
    });

    test('should return error for password without letters', () => {
        expect(validatePassword('123456'))
            .toBe('Password must contain at least one letter');
    });

    // Test password hợp lệ
    test('should return null for valid password', () => {
        expect(validatePassword('Pass123')).toBeNull();
    });

    test('should return null for min valid length (6 chars)', () => {
        expect(validatePassword('Pass12')).toBeNull();
    });

    test('should return null for max valid length (100 chars)', () => {
        const maxPassword = 'a'.repeat(50) + '1'.repeat(50);
        expect(validatePassword(maxPassword)).toBeNull();
    });
});
\end{verbatim}

\textbf{c) Coverage >= 90\% cho validation module (1 điểm)}:

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{File} & \textbf{Statements} & \textbf{Branches} & \textbf{Functions} & \textbf{Lines} \\ \hline
validators.js & 100\% & 100\% & 100\% & 100\% \\ \hline
\end{tabular}
\caption{Coverage Report - Frontend Validators}
\end{table}

\begin{verbatim}
$ npm test -- --coverage src/tests/unit/validators.test.js

 PASS  src/tests/unit/validators.test.js
  validateUsername
    ✓ should return error for null username (2 ms)
    ✓ should return error for empty string (1 ms)
    ✓ should return error for username too short
    ✓ should return error for username too long
    ...
  validatePassword
    ✓ should return error for null password
    ✓ should return error for password without numbers
    ...

Test Suites: 1 passed, 1 total
Tests:       85 passed, 85 total
Coverage:    100%
\end{verbatim}

\newpage

\subsubsection{Backend Unit Tests - Login Service (5 điểm)}

\textbf{a) Test method authenticate() với các scenarios (3 điểm)}:

\textbf{File}: \texttt{com.flogin.unit.service.auth.AuthServiceTest.java}

\begin{verbatim}
@ExtendWith(MockitoExtension.class)
class AuthServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @InjectMocks
    private AuthService authService;

    // Login thành công
    @Test
    @DisplayName("Login: Success - Correct credentials")
    void login_Success() {
        when(userRepository.findByUsername(anyString()))
            .thenReturn(Optional.of(user));
        when(passwordEncoder.matches(anyString(), anyString()))
            .thenReturn(true);

        User result = authService.login(loginRequest);

        assertNotNull(result);
        assertEquals("testuser", result.getUsername());
    }

    // Login với username không tồn tại
    @Test
    @DisplayName("Login: Failure - User not found")
    void login_UserNotFound() {
        when(userRepository.findByUsername(anyString()))
            .thenReturn(Optional.empty());

        assertThrows(BadRequestException.class, 
            () -> authService.login(loginRequest));
    }

    // Login với password sai
    @Test
    @DisplayName("Login: Failure - Wrong password")
    void login_WrongPassword() {
        when(userRepository.findByUsername(anyString()))
            .thenReturn(Optional.of(user));
        when(passwordEncoder.matches(anyString(), anyString()))
            .thenReturn(false);

        assertThrows(BadRequestException.class, 
            () -> authService.login(loginRequest));
    }

    // Validation errors - Register with existing username
    @Test
    @DisplayName("Register: Failure - Username already exists")
    void register_UsernameExists() {
        when(userRepository.existsByUsername(anyString()))
            .thenReturn(true);

        assertThrows(BadRequestException.class, 
            () -> authService.register(registerRequest));
        verify(userRepository, never()).save(any(User.class));
    }
}
\end{verbatim}

\textbf{b) Test validation methods riêng lẻ (1 điểm)}:

\begin{verbatim}
@Test
@DisplayName("Register: Success - Valid credentials")
void register_Success() {
    when(userRepository.existsByUsername(anyString())).thenReturn(false);
    when(userRepository.existsByEmail(anyString())).thenReturn(false);
    when(passwordEncoder.encode(anyString())).thenReturn("encodedPassword");
    when(userRepository.save(any(User.class))).thenReturn(user);

    User result = authService.register(registerRequest);

    assertNotNull(result);
    assertEquals("testuser", result.getUsername());
    verify(userRepository).save(any(User.class));
}
\end{verbatim}

\textbf{c) Coverage >= 85\% cho AuthService (1 điểm)}:

\begin{verbatim}
$ mvn test -Dtest=AuthServiceTest jacoco:report

Tests run: 5, Failures: 0, Errors: 0, Skipped: 0

Coverage Report:
- AuthService.java: 87% line coverage
- Methods covered: login(), register(), validateUser()
\end{verbatim}

\newpage

\subsection{Câu 2.2: Product - Unit Tests Frontend và Backend (10 điểm)}

\subsubsection{Frontend Unit Tests - Product Validation (5 điểm)}

\textbf{a) Unit tests cho validateProduct() (3 điểm)}:

\begin{verbatim}
describe('validateProduct', () => {
    // Test product name validation
    test('should return error for missing name', () => {
        const product = { price: 99.99, quantity: 10 };
        const result = validateProduct(product);
        expect(result.valid).toBe(false);
        expect(result.errors.name).toBe('Product name is required');
    });

    test('should return error for name too short', () => {
        const product = { name: 'ab', price: 99.99, quantity: 10 };
        const result = validateProduct(product);
        expect(result.errors.name)
            .toBe('Product name must be at least 3 characters');
    });

    // Test price validation (boundary tests)
    test('should return error for zero price', () => {
        const product = { name: 'Test', price: 0, quantity: 10 };
        const result = validateProduct(product);
        expect(result.errors.price)
            .toBe('Price must be greater than 0');
    });

    test('should return error for negative price', () => {
        const product = { name: 'Test', price: -10, quantity: 10 };
        const result = validateProduct(product);
        expect(result.errors.price)
            .toBe('Price must be greater than 0');
    });

    test('should return valid for min price (0.01)', () => {
        const product = { name: 'Test', price: 0.01, quantity: 10 };
        const result = validateProduct(product);
        expect(result.valid).toBe(true);
    });

    test('should return valid for max price (999,999,999)', () => {
        const product = { name: 'Test', price: 999999999, quantity: 1 };
        const result = validateProduct(product);
        expect(result.valid).toBe(true);
    });

    // Test quantity validation
    test('should return error for negative quantity', () => {
        const product = { name: 'Test', price: 100, quantity: -5 };
        const result = validateProduct(product);
        expect(result.errors.quantity)
            .toBe('Quantity must be greater than or equal to 0');
    });

    test('should return valid for zero quantity (out of stock)', () => {
        const product = { name: 'Test', price: 100, quantity: 0 };
        const result = validateProduct(product);
        expect(result.valid).toBe(true);
    });

    // Test description length
    test('should return error for description > 500 chars', () => {
        const product = {
            name: 'Test', price: 100, quantity: 10,
            description: 'a'.repeat(501)
        };
        const result = validateProduct(product);
        expect(result.errors.description)
            .toBe('Description must not exceed 500 characters');
    });
});
\end{verbatim}

\textbf{b) Tests cho Product form component (1 điểm)}:

\begin{verbatim}
// ProductForm.test.jsx
describe('ProductForm Component', () => {
    test('renders create mode correctly', () => {
        render(<ProductForm mode="create" />);
        expect(screen.getByText('Create Product')).toBeInTheDocument();
    });

    test('renders edit mode with existing data', () => {
        const product = { id: 1, name: 'Test', price: 100, quantity: 5 };
        render(<ProductForm mode="edit" product={product} />);
        expect(screen.getByDisplayValue('Test')).toBeInTheDocument();
    });

    test('shows validation error on submit with empty name', async () => {
        render(<ProductForm mode="create" />);
        fireEvent.click(screen.getByText('Save'));
        await waitFor(() => {
            expect(screen.getByText(/required/i)).toBeInTheDocument();
        });
    });
});
\end{verbatim}

\textbf{c) Coverage >= 90\% (1 điểm)}:

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{File} & \textbf{Statements} & \textbf{Branches} & \textbf{Functions} & \textbf{Lines} \\ \hline
validators.js (Product) & 100\% & 100\% & 100\% & 100\% \\ \hline
ProductForm.jsx & 95\% & 91\% & 100\% & 95\% \\ \hline
\end{tabular}
\caption{Coverage Report - Product Validation}
\end{table}

\newpage

\subsubsection{Backend Unit Tests - Product Service (5 điểm)}

\textbf{a) Test CRUD operations (4 điểm)}:

\begin{verbatim}
@ExtendWith(MockitoExtension.class)
class ProductServiceTest {

    @Mock private ProductRepository productRepository;
    @Mock private ProductMapper productMapper;
    @InjectMocks private ProductService productService;

    // Test createProduct()
    @Test
    @DisplayName("Create Product: Success")
    void createProduct_Success() {
        when(productMapper.toEntity(any())).thenReturn(product);
        when(productRepository.save(any())).thenReturn(product);
        when(productMapper.toResponse(any())).thenReturn(productResponse);

        ProductResponse result = productService.createProduct(request);

        assertNotNull(result);
        assertEquals("Test Product", result.getName());
        verify(productRepository).save(any(Product.class));
    }

    // Test getProduct()
    @Test
    @DisplayName("Get Product By ID: Success")
    void getProductById_Success() {
        when(productRepository.findById(1L))
            .thenReturn(Optional.of(product));
        when(productMapper.toResponse(any())).thenReturn(productResponse);

        ProductResponse result = productService.getProductById(1L);

        assertEquals(1L, result.getId());
    }

    @Test
    @DisplayName("Get Product By ID: Not Found")
    void getProductById_NotFound() {
        when(productRepository.findById(1L)).thenReturn(Optional.empty());

        assertThrows(NotFoundException.class, 
            () -> productService.getProductById(1L));
    }

    // Test updateProduct()
    @Test
    @DisplayName("Update Product: Success")
    void updateProduct_Success() {
        when(productRepository.findById(1L))
            .thenReturn(Optional.of(product));
        when(productRepository.save(any())).thenReturn(product);
        when(productMapper.toResponse(any())).thenReturn(productResponse);

        ProductResponse result = productService.updateProduct(1L, request);

        assertNotNull(result);
        verify(productRepository).save(any(Product.class));
    }

    // Test deleteProduct()
    @Test
    @DisplayName("Delete Product: Success")
    void deleteProduct_Success() {
        when(productRepository.existsById(1L)).thenReturn(true);
        doNothing().when(productRepository).deleteById(1L);

        assertDoesNotThrow(() -> productService.deleteProduct(1L));
        verify(productRepository).deleteById(1L);
    }

    @Test
    @DisplayName("Delete Product: Not Found")
    void deleteProduct_NotFound() {
        when(productRepository.existsById(1L)).thenReturn(false);

        assertThrows(NotFoundException.class, 
            () -> productService.deleteProduct(1L));
        verify(productRepository, never()).deleteById(anyLong());
    }

    // Test getAll() với pagination
    @Test
    @DisplayName("Get All Products: With Pagination")
    void getAllProducts_WithPagination() {
        List<Product> products = Arrays.asList(product);
        when(productRepository.findAll()).thenReturn(products);

        List<ProductResponse> result = productService.getAllProducts();

        assertFalse(result.isEmpty());
    }
}
\end{verbatim}

\textbf{b) Coverage >= 85\% cho ProductService (1 điểm)}:

\begin{verbatim}
$ mvn test -Dtest=ProductServiceTest jacoco:report

Tests run: 7, Failures: 0, Errors: 0, Skipped: 0

Coverage Report:
- ProductService.java: 89% line coverage
- Methods covered: createProduct(), getProductById(), 
                   getAllProducts(), updateProduct(), deleteProduct()
\end{verbatim}

\newpage

\subsection{Test-Driven Development (TDD) Process}

Quy trình TDD được áp dụng nghiêm ngặt:

\textbf{1. RED Phase - Viết test trước}:
\begin{itemize}
    \item Xác định requirements từ đề bài
    \item Viết test case cho từng requirement
    \item Test fail vì chưa có implementation
\end{itemize}

\textbf{2. GREEN Phase - Implement code}:
\begin{itemize}
    \item Viết code tối thiểu để pass test
    \item Focus vào functionality, chưa optimize
    \item Run test và verify PASS
\end{itemize}

\textbf{3. REFACTOR Phase - Cải thiện code}:
\begin{itemize}
    \item Refactor code để clean hơn
    \item Loại bỏ duplication
    \item Đảm bảo tests vẫn pass
\end{itemize}

\textbf{Tổng kết Câu 2}:
\begin{itemize}
    \item \textbf{Frontend Login Tests}: 20+ tests cho validateUsername(), validatePassword()
    \item \textbf{Backend Login Tests}: 5 tests cho AuthService (login, register)
    \item \textbf{Frontend Product Tests}: 50+ tests cho validateProduct()
    \item \textbf{Backend Product Tests}: 7 tests cho ProductService CRUD
    \item \textbf{Coverage}: Frontend 100\%, Backend 87\%
\end{itemize}

\newpage
